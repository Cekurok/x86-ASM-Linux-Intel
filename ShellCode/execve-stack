
We must push the string of args ontop of the stack in reverse. This can be done with python in the following 1 liner.

[*] Python:
  python -c 'string="////bin/bash";splitNum=8;print "\nLength: %s" % len(string[::-1]);string=string[::-1].encode("hex"); \
  string=["push 0x"+str(string[i:i+splitNum]) for i in range(0, len(string), splitNum)]; \
  print "Hex List:\n"; print("\n".join(h for h in string))'
  
  The line above will take a string, provide you the length of it and produce the hex in a readable and useable format
  for our shellcode
  
Then we can reference it on the stack with ESP keeping everything dynamic


We first will need to push a dword of null onto the stack
xor eax, eax
push eax

We are going to want to keep our string divisable by 4 so we can keep things even. When dealing with Linux executables
/bin/bash is 9 chars.
////bin/bash is 12 chars and since linux does not care how many slashes there are this will run correctly.

push 0x68736162
push 0x2f6e6962
push 0x2f2f2f2f

The above is ////bin/bash ran through our pythong one liner above

Once this is pushed onto the stack ESP will now point to our /bin/bash & null chars.

	mov ebx, esp ; this moves the memory address of esp(pointing to our string & nulls)
		     ; from the stack into ebx where execve is expecting the name of the application + a null
	
	push eax ; this pushes another null onto the stack
	mov edx, esp ; this now gets the memory address of the nulls we just pushed onto the stack into edx, this is for envp so it can just be null
	; STACK: 0x0000, OURSTRING, 0x0000
	
	push ebx ; this pushes the memory address of our string onto the stack
	mov ecx, esp ; this moves the address of our string from the stack to ecx
	; STACK: OURSTRING, 0x0000, OURSTRING, 0x0000
	
	
	now we just run syscall #11 for execve and we get a shell
	
	

